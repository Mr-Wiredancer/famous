<!DOCTYPE html>

<html>
<head>
  <title>Transform.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="Context.html">
                Context.js
              </a>
            
              
              <a class="source" href="ElementAllocator.html">
                ElementAllocator.js
              </a>
            
              
              <a class="source" href="ElementOutput.html">
                ElementOutput.js
              </a>
            
              
              <a class="source" href="Engine.html">
                Engine.js
              </a>
            
              
              <a class="source" href="Entity.html">
                Entity.js
              </a>
            
              
              <a class="source" href="EventEmitter.html">
                EventEmitter.js
              </a>
            
              
              <a class="source" href="EventHandler.html">
                EventHandler.js
              </a>
            
              
              <a class="source" href="Group.html">
                Group.js
              </a>
            
              
              <a class="source" href="Modifier.html">
                Modifier.js
              </a>
            
              
              <a class="source" href="OptionsManager.html">
                OptionsManager.js
              </a>
            
              
              <a class="source" href="RenderNode.html">
                RenderNode.js
              </a>
            
              
              <a class="source" href="Scene.html">
                Scene.js
              </a>
            
              
              <a class="source" href="SpecParser.html">
                SpecParser.js
              </a>
            
              
              <a class="source" href="Surface.html">
                Surface.js
              </a>
            
              
              <a class="source" href="Transform.html">
                Transform.js
              </a>
            
              
              <a class="source" href="View.html">
                View.js
              </a>
            
              
              <a class="source" href="ViewSequence.html">
                ViewSequence.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>Transform.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * Owner: mark@famo.us
 * @license MPL 2.0
 * @copyright Famous Industries, Inc. 2014
 */</span>

define(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(require, exports, module)</span> </span>{

    <span class="hljs-comment">/**
     *  A high-performance static matrix math library used to calculate
     *    affine transforms on surfaces and other renderables.
     *    Famo.us uses 4x4 matrices corresponding directly to
     *    WebKit matrices (column-major order).
     *
     *    The internal "type" of a Matrix is a 16-long float array in
     *    row-major order, with:
     *    elements [0],[1],[2],[4],[5],[6],[8],[9],[10] forming the 3x3
     *          transformation matrix;
     *    elements [12], [13], [14] corresponding to the t_x, t_y, t_z
     *           translation;
     *    elements [3], [7], [11] set to 0;
     *    element [15] set to 1.
     *    All methods are static.
     *
     * @static
     *
     * @class Transform
     */</span>
    <span class="hljs-keyword">var</span> Transform = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>WARNING: these matrices correspond to WebKit matrices, which are
   transposed from their math counterparts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Transform.precision = <span class="hljs-number">1e-6</span>;
    Transform.identity = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];

    <span class="hljs-comment">/**
     * Multiply two or more Transform matrix types to return a Transform matrix.
     *
     * @method multiply4x4
     * @static
     * @param {Transform} a left Transform
     * @param {Transform} b right Transform
     * @return {Transform}
     */</span>
    Transform.multiply4x4 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply4x4</span><span class="hljs-params">(a, b)</span> </span>{
        <span class="hljs-keyword">return</span> [
            a[<span class="hljs-number">0</span>] * b[<span class="hljs-number">0</span>] + a[<span class="hljs-number">4</span>] * b[<span class="hljs-number">1</span>] + a[<span class="hljs-number">8</span>] * b[<span class="hljs-number">2</span>] + a[<span class="hljs-number">12</span>] * b[<span class="hljs-number">3</span>],
            a[<span class="hljs-number">1</span>] * b[<span class="hljs-number">0</span>] + a[<span class="hljs-number">5</span>] * b[<span class="hljs-number">1</span>] + a[<span class="hljs-number">9</span>] * b[<span class="hljs-number">2</span>] + a[<span class="hljs-number">13</span>] * b[<span class="hljs-number">3</span>],
            a[<span class="hljs-number">2</span>] * b[<span class="hljs-number">0</span>] + a[<span class="hljs-number">6</span>] * b[<span class="hljs-number">1</span>] + a[<span class="hljs-number">10</span>] * b[<span class="hljs-number">2</span>] + a[<span class="hljs-number">14</span>] * b[<span class="hljs-number">3</span>],
            a[<span class="hljs-number">3</span>] * b[<span class="hljs-number">0</span>] + a[<span class="hljs-number">7</span>] * b[<span class="hljs-number">1</span>] + a[<span class="hljs-number">11</span>] * b[<span class="hljs-number">2</span>] + a[<span class="hljs-number">15</span>] * b[<span class="hljs-number">3</span>],
            a[<span class="hljs-number">0</span>] * b[<span class="hljs-number">4</span>] + a[<span class="hljs-number">4</span>] * b[<span class="hljs-number">5</span>] + a[<span class="hljs-number">8</span>] * b[<span class="hljs-number">6</span>] + a[<span class="hljs-number">12</span>] * b[<span class="hljs-number">7</span>],
            a[<span class="hljs-number">1</span>] * b[<span class="hljs-number">4</span>] + a[<span class="hljs-number">5</span>] * b[<span class="hljs-number">5</span>] + a[<span class="hljs-number">9</span>] * b[<span class="hljs-number">6</span>] + a[<span class="hljs-number">13</span>] * b[<span class="hljs-number">7</span>],
            a[<span class="hljs-number">2</span>] * b[<span class="hljs-number">4</span>] + a[<span class="hljs-number">6</span>] * b[<span class="hljs-number">5</span>] + a[<span class="hljs-number">10</span>] * b[<span class="hljs-number">6</span>] + a[<span class="hljs-number">14</span>] * b[<span class="hljs-number">7</span>],
            a[<span class="hljs-number">3</span>] * b[<span class="hljs-number">4</span>] + a[<span class="hljs-number">7</span>] * b[<span class="hljs-number">5</span>] + a[<span class="hljs-number">11</span>] * b[<span class="hljs-number">6</span>] + a[<span class="hljs-number">15</span>] * b[<span class="hljs-number">7</span>],
            a[<span class="hljs-number">0</span>] * b[<span class="hljs-number">8</span>] + a[<span class="hljs-number">4</span>] * b[<span class="hljs-number">9</span>] + a[<span class="hljs-number">8</span>] * b[<span class="hljs-number">10</span>] + a[<span class="hljs-number">12</span>] * b[<span class="hljs-number">11</span>],
            a[<span class="hljs-number">1</span>] * b[<span class="hljs-number">8</span>] + a[<span class="hljs-number">5</span>] * b[<span class="hljs-number">9</span>] + a[<span class="hljs-number">9</span>] * b[<span class="hljs-number">10</span>] + a[<span class="hljs-number">13</span>] * b[<span class="hljs-number">11</span>],
            a[<span class="hljs-number">2</span>] * b[<span class="hljs-number">8</span>] + a[<span class="hljs-number">6</span>] * b[<span class="hljs-number">9</span>] + a[<span class="hljs-number">10</span>] * b[<span class="hljs-number">10</span>] + a[<span class="hljs-number">14</span>] * b[<span class="hljs-number">11</span>],
            a[<span class="hljs-number">3</span>] * b[<span class="hljs-number">8</span>] + a[<span class="hljs-number">7</span>] * b[<span class="hljs-number">9</span>] + a[<span class="hljs-number">11</span>] * b[<span class="hljs-number">10</span>] + a[<span class="hljs-number">15</span>] * b[<span class="hljs-number">11</span>],
            a[<span class="hljs-number">0</span>] * b[<span class="hljs-number">12</span>] + a[<span class="hljs-number">4</span>] * b[<span class="hljs-number">13</span>] + a[<span class="hljs-number">8</span>] * b[<span class="hljs-number">14</span>] + a[<span class="hljs-number">12</span>] * b[<span class="hljs-number">15</span>],
            a[<span class="hljs-number">1</span>] * b[<span class="hljs-number">12</span>] + a[<span class="hljs-number">5</span>] * b[<span class="hljs-number">13</span>] + a[<span class="hljs-number">9</span>] * b[<span class="hljs-number">14</span>] + a[<span class="hljs-number">13</span>] * b[<span class="hljs-number">15</span>],
            a[<span class="hljs-number">2</span>] * b[<span class="hljs-number">12</span>] + a[<span class="hljs-number">6</span>] * b[<span class="hljs-number">13</span>] + a[<span class="hljs-number">10</span>] * b[<span class="hljs-number">14</span>] + a[<span class="hljs-number">14</span>] * b[<span class="hljs-number">15</span>],
            a[<span class="hljs-number">3</span>] * b[<span class="hljs-number">12</span>] + a[<span class="hljs-number">7</span>] * b[<span class="hljs-number">13</span>] + a[<span class="hljs-number">11</span>] * b[<span class="hljs-number">14</span>] + a[<span class="hljs-number">15</span>] * b[<span class="hljs-number">15</span>]
        ];
    };

    <span class="hljs-comment">/**
     * Fast-multiply two or more Transform matrix types to return a
     *    Matrix, assuming bottom row on each is [0 0 0 1].
     *
     * @method multiply
     * @static
     * @param {Transform} a left Transform
     * @param {Transform} b right Transform
     * @return {Transform}
     */</span>
    Transform.multiply = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span><span class="hljs-params">(a, b)</span> </span>{
        <span class="hljs-keyword">return</span> [
            a[<span class="hljs-number">0</span>] * b[<span class="hljs-number">0</span>] + a[<span class="hljs-number">4</span>] * b[<span class="hljs-number">1</span>] + a[<span class="hljs-number">8</span>] * b[<span class="hljs-number">2</span>],
            a[<span class="hljs-number">1</span>] * b[<span class="hljs-number">0</span>] + a[<span class="hljs-number">5</span>] * b[<span class="hljs-number">1</span>] + a[<span class="hljs-number">9</span>] * b[<span class="hljs-number">2</span>],
            a[<span class="hljs-number">2</span>] * b[<span class="hljs-number">0</span>] + a[<span class="hljs-number">6</span>] * b[<span class="hljs-number">1</span>] + a[<span class="hljs-number">10</span>] * b[<span class="hljs-number">2</span>],
            <span class="hljs-number">0</span>,
            a[<span class="hljs-number">0</span>] * b[<span class="hljs-number">4</span>] + a[<span class="hljs-number">4</span>] * b[<span class="hljs-number">5</span>] + a[<span class="hljs-number">8</span>] * b[<span class="hljs-number">6</span>],
            a[<span class="hljs-number">1</span>] * b[<span class="hljs-number">4</span>] + a[<span class="hljs-number">5</span>] * b[<span class="hljs-number">5</span>] + a[<span class="hljs-number">9</span>] * b[<span class="hljs-number">6</span>],
            a[<span class="hljs-number">2</span>] * b[<span class="hljs-number">4</span>] + a[<span class="hljs-number">6</span>] * b[<span class="hljs-number">5</span>] + a[<span class="hljs-number">10</span>] * b[<span class="hljs-number">6</span>],
            <span class="hljs-number">0</span>,
            a[<span class="hljs-number">0</span>] * b[<span class="hljs-number">8</span>] + a[<span class="hljs-number">4</span>] * b[<span class="hljs-number">9</span>] + a[<span class="hljs-number">8</span>] * b[<span class="hljs-number">10</span>],
            a[<span class="hljs-number">1</span>] * b[<span class="hljs-number">8</span>] + a[<span class="hljs-number">5</span>] * b[<span class="hljs-number">9</span>] + a[<span class="hljs-number">9</span>] * b[<span class="hljs-number">10</span>],
            a[<span class="hljs-number">2</span>] * b[<span class="hljs-number">8</span>] + a[<span class="hljs-number">6</span>] * b[<span class="hljs-number">9</span>] + a[<span class="hljs-number">10</span>] * b[<span class="hljs-number">10</span>],
            <span class="hljs-number">0</span>,
            a[<span class="hljs-number">0</span>] * b[<span class="hljs-number">12</span>] + a[<span class="hljs-number">4</span>] * b[<span class="hljs-number">13</span>] + a[<span class="hljs-number">8</span>] * b[<span class="hljs-number">14</span>] + a[<span class="hljs-number">12</span>],
            a[<span class="hljs-number">1</span>] * b[<span class="hljs-number">12</span>] + a[<span class="hljs-number">5</span>] * b[<span class="hljs-number">13</span>] + a[<span class="hljs-number">9</span>] * b[<span class="hljs-number">14</span>] + a[<span class="hljs-number">13</span>],
            a[<span class="hljs-number">2</span>] * b[<span class="hljs-number">12</span>] + a[<span class="hljs-number">6</span>] * b[<span class="hljs-number">13</span>] + a[<span class="hljs-number">10</span>] * b[<span class="hljs-number">14</span>] + a[<span class="hljs-number">14</span>],
            <span class="hljs-number">1</span>
        ];
    };

    <span class="hljs-comment">/**
     * Return a Transform translated by additional amounts in each
     *    dimension. This is equivalent to the result of
     *
     *    Transform.multiply(Matrix.translate(t[0], t[1], t[2]), m).
     *
     * @method thenMove
     * @static
     * @param {Transform} m a Transform
     * @param {Array.Number} t floats delta vector of length 2 or 3
     * @return {Transform}
     */</span>
    Transform.thenMove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thenMove</span><span class="hljs-params">(m, t)</span> </span>{
        <span class="hljs-keyword">if</span> (!t[<span class="hljs-number">2</span>]) t[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> [m[<span class="hljs-number">0</span>], m[<span class="hljs-number">1</span>], m[<span class="hljs-number">2</span>], <span class="hljs-number">0</span>, m[<span class="hljs-number">4</span>], m[<span class="hljs-number">5</span>], m[<span class="hljs-number">6</span>], <span class="hljs-number">0</span>, m[<span class="hljs-number">8</span>], m[<span class="hljs-number">9</span>], m[<span class="hljs-number">10</span>], <span class="hljs-number">0</span>, m[<span class="hljs-number">12</span>] + t[<span class="hljs-number">0</span>], m[<span class="hljs-number">13</span>] + t[<span class="hljs-number">1</span>], m[<span class="hljs-number">14</span>] + t[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>];
    };

    <span class="hljs-comment">/**
     * Return a Transform atrix which represents the result of a transform matrix
     *    applied after a move. This is faster than the equivalent multiply.
     *    This is equivalent to the result of:
     *
     *    Transform.multiply(m, Transform.translate(t[0], t[1], t[2])).
     *
     * @method moveThen
     * @static
     * @param {Array.Number} v vector representing initial movement
     * @param {Transform} m matrix to apply afterwards
     * @return {Transform} the resulting matrix
     */</span>
    Transform.moveThen = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveThen</span><span class="hljs-params">(v, m)</span> </span>{
        <span class="hljs-keyword">if</span> (!v[<span class="hljs-number">2</span>]) v[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> t0 = v[<span class="hljs-number">0</span>] * m[<span class="hljs-number">0</span>] + v[<span class="hljs-number">1</span>] * m[<span class="hljs-number">4</span>] + v[<span class="hljs-number">2</span>] * m[<span class="hljs-number">8</span>];
        <span class="hljs-keyword">var</span> t1 = v[<span class="hljs-number">0</span>] * m[<span class="hljs-number">1</span>] + v[<span class="hljs-number">1</span>] * m[<span class="hljs-number">5</span>] + v[<span class="hljs-number">2</span>] * m[<span class="hljs-number">9</span>];
        <span class="hljs-keyword">var</span> t2 = v[<span class="hljs-number">0</span>] * m[<span class="hljs-number">2</span>] + v[<span class="hljs-number">1</span>] * m[<span class="hljs-number">6</span>] + v[<span class="hljs-number">2</span>] * m[<span class="hljs-number">10</span>];
        <span class="hljs-keyword">return</span> Transform.thenMove(m, [t0, t1, t2]);
    };

    <span class="hljs-comment">/**
     * Return a Transform which represents a translation by specified
     *    amounts in each dimension.
     *
     * @method translate
     * @static
     * @param {Number} x x translation
     * @param {Number} y y translation
     * @param {Number} z z translation
     * @return {Transform}
     */</span>
    Transform.translate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">translate</span><span class="hljs-params">(x, y, z)</span> </span>{
        <span class="hljs-keyword">if</span> (z === <span class="hljs-literal">undefined</span>) z = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, x, y, z, <span class="hljs-number">1</span>];
    };

    <span class="hljs-comment">/**
     * Return a Transform scaled by a vector in each
     *    dimension. This is a more performant equivalent to the result of
     *
     *    Transform.multiply(Transform.scale(s[0], s[1], s[2]), m).
     *
     * @method thenScale
     * @static
     * @param {Transform} m a matrix
     * @param {Array.Number} s delta vector (array of floats &amp;&amp;
     *    array.length == 3)
     * @return {Transform}
     */</span>
    Transform.thenScale = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thenScale</span><span class="hljs-params">(m, s)</span> </span>{
        <span class="hljs-keyword">return</span> [
            s[<span class="hljs-number">0</span>] * m[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>] * m[<span class="hljs-number">1</span>], s[<span class="hljs-number">2</span>] * m[<span class="hljs-number">2</span>], <span class="hljs-number">0</span>,
            s[<span class="hljs-number">0</span>] * m[<span class="hljs-number">4</span>], s[<span class="hljs-number">1</span>] * m[<span class="hljs-number">5</span>], s[<span class="hljs-number">2</span>] * m[<span class="hljs-number">6</span>], <span class="hljs-number">0</span>,
            s[<span class="hljs-number">0</span>] * m[<span class="hljs-number">8</span>], s[<span class="hljs-number">1</span>] * m[<span class="hljs-number">9</span>], s[<span class="hljs-number">2</span>] * m[<span class="hljs-number">10</span>], <span class="hljs-number">0</span>,
            s[<span class="hljs-number">0</span>] * m[<span class="hljs-number">12</span>], s[<span class="hljs-number">1</span>] * m[<span class="hljs-number">13</span>], s[<span class="hljs-number">2</span>] * m[<span class="hljs-number">14</span>], <span class="hljs-number">1</span>
        ];
    };

    <span class="hljs-comment">/**
     * Return a Transform which represents a scale by specified amounts
     *    in each dimension.
     *
     * @method scale
     * @static
     * @param {Number} x x scale factor
     * @param {Number} y y scale factor
     * @param {Number} z z scale factor
     * @return {Transform}
     */</span>
    Transform.scale = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scale</span><span class="hljs-params">(x, y, z)</span> </span>{
        <span class="hljs-keyword">if</span> (z === <span class="hljs-literal">undefined</span>) z = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (y === <span class="hljs-literal">undefined</span>) y = x;
        <span class="hljs-keyword">return</span> [x, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, y, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, z, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];
    };

    <span class="hljs-comment">/**
     * Return a Transform which represents a clockwise
     *    rotation around the x axis.
     *
     * @method rotateX
     * @static
     * @param {Number} theta radians
     * @return {Transform}
     */</span>
    Transform.rotateX = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rotateX</span><span class="hljs-params">(theta)</span> </span>{
        <span class="hljs-keyword">var</span> cosTheta = <span class="hljs-built_in">Math</span>.cos(theta);
        <span class="hljs-keyword">var</span> sinTheta = <span class="hljs-built_in">Math</span>.sin(theta);
        <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, cosTheta, sinTheta, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -sinTheta, cosTheta, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];
    };

    <span class="hljs-comment">/**
     * Return a Transform which represents a clockwise
     *    rotation around the y axis.
     *
     * @method rotateY
     * @static
     * @param {Number} theta radians
     * @return {Transform}
     */</span>
    Transform.rotateY = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rotateY</span><span class="hljs-params">(theta)</span> </span>{
        <span class="hljs-keyword">var</span> cosTheta = <span class="hljs-built_in">Math</span>.cos(theta);
        <span class="hljs-keyword">var</span> sinTheta = <span class="hljs-built_in">Math</span>.sin(theta);
        <span class="hljs-keyword">return</span> [cosTheta, <span class="hljs-number">0</span>, -sinTheta, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, sinTheta, <span class="hljs-number">0</span>, cosTheta, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];
    };

    <span class="hljs-comment">/**
     * Return a Transform which represents a clockwise
     *    rotation around the z axis.
     *
     * @method rotateZ
     * @static
     * @param {Number} theta radians
     * @return {Transform}
     */</span>
    Transform.rotateZ = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rotateZ</span><span class="hljs-params">(theta)</span> </span>{
        <span class="hljs-keyword">var</span> cosTheta = <span class="hljs-built_in">Math</span>.cos(theta);
        <span class="hljs-keyword">var</span> sinTheta = <span class="hljs-built_in">Math</span>.sin(theta);
        <span class="hljs-keyword">return</span> [cosTheta, sinTheta, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -sinTheta, cosTheta, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];
    };

    <span class="hljs-comment">/**
     * Return a Transform which represents composed clockwise
     *    rotations along each of the axes. Equivalent to the result of
     *    Matrix.multiply(rotateX(phi), rotateY(theta), rotateZ(psi)).
     *
     * @method rotate
     * @static
     * @param {Number} phi radians to rotate about the positive x axis
     * @param {Number} theta radians to rotate about the positive y axis
     * @param {Number} psi radians to rotate about the positive z axis
     * @return {Transform}
     */</span>
    Transform.rotate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rotate</span><span class="hljs-params">(phi, theta, psi)</span> </span>{
        <span class="hljs-keyword">var</span> cosPhi = <span class="hljs-built_in">Math</span>.cos(phi);
        <span class="hljs-keyword">var</span> sinPhi = <span class="hljs-built_in">Math</span>.sin(phi);
        <span class="hljs-keyword">var</span> cosTheta = <span class="hljs-built_in">Math</span>.cos(theta);
        <span class="hljs-keyword">var</span> sinTheta = <span class="hljs-built_in">Math</span>.sin(theta);
        <span class="hljs-keyword">var</span> cosPsi = <span class="hljs-built_in">Math</span>.cos(psi);
        <span class="hljs-keyword">var</span> sinPsi = <span class="hljs-built_in">Math</span>.sin(psi);
        <span class="hljs-keyword">var</span> result = [
            cosTheta * cosPsi,
            cosPhi * sinPsi + sinPhi * sinTheta * cosPsi,
            sinPhi * sinPsi - cosPhi * sinTheta * cosPsi,
            <span class="hljs-number">0</span>,
            -cosTheta * sinPsi,
            cosPhi * cosPsi - sinPhi * sinTheta * sinPsi,
            sinPhi * cosPsi + cosPhi * sinTheta * sinPsi,
            <span class="hljs-number">0</span>,
            sinTheta,
            -sinPhi * cosTheta,
            cosPhi * cosTheta,
            <span class="hljs-number">0</span>,
            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
        ];
        <span class="hljs-keyword">return</span> result;
    };

    <span class="hljs-comment">/**
     * Return a Transform which represents an axis-angle rotation
     *
     * @method rotateAxis
     * @static
     * @param {Array.Number} v unit vector representing the axis to rotate about
     * @param {Number} theta radians to rotate clockwise about the axis
     * @return {Transform}
     */</span>
    Transform.rotateAxis = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rotateAxis</span><span class="hljs-params">(v, theta)</span> </span>{
        <span class="hljs-keyword">var</span> sinTheta = <span class="hljs-built_in">Math</span>.sin(theta);
        <span class="hljs-keyword">var</span> cosTheta = <span class="hljs-built_in">Math</span>.cos(theta);
        <span class="hljs-keyword">var</span> verTheta = <span class="hljs-number">1</span> - cosTheta; <span class="hljs-comment">// versine of theta</span>

        <span class="hljs-keyword">var</span> xxV = v[<span class="hljs-number">0</span>] * v[<span class="hljs-number">0</span>] * verTheta;
        <span class="hljs-keyword">var</span> xyV = v[<span class="hljs-number">0</span>] * v[<span class="hljs-number">1</span>] * verTheta;
        <span class="hljs-keyword">var</span> xzV = v[<span class="hljs-number">0</span>] * v[<span class="hljs-number">2</span>] * verTheta;
        <span class="hljs-keyword">var</span> yyV = v[<span class="hljs-number">1</span>] * v[<span class="hljs-number">1</span>] * verTheta;
        <span class="hljs-keyword">var</span> yzV = v[<span class="hljs-number">1</span>] * v[<span class="hljs-number">2</span>] * verTheta;
        <span class="hljs-keyword">var</span> zzV = v[<span class="hljs-number">2</span>] * v[<span class="hljs-number">2</span>] * verTheta;
        <span class="hljs-keyword">var</span> xs = v[<span class="hljs-number">0</span>] * sinTheta;
        <span class="hljs-keyword">var</span> ys = v[<span class="hljs-number">1</span>] * sinTheta;
        <span class="hljs-keyword">var</span> zs = v[<span class="hljs-number">2</span>] * sinTheta;

        <span class="hljs-keyword">var</span> result = [
            xxV + cosTheta, xyV + zs, xzV - ys, <span class="hljs-number">0</span>,
            xyV - zs, yyV + cosTheta, yzV + xs, <span class="hljs-number">0</span>,
            xzV + ys, yzV - xs, zzV + cosTheta, <span class="hljs-number">0</span>,
            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
        ];
        <span class="hljs-keyword">return</span> result;
    };

    <span class="hljs-comment">/**
     * Return a Transform which represents a transform matrix applied about
     * a separate origin point.
     *
     * @method aboutOrigin
     * @static
     * @param {Array.Number} v origin point to apply matrix
     * @param {Transform} m matrix to apply
     * @return {Transform}
     */</span>
    Transform.aboutOrigin = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aboutOrigin</span><span class="hljs-params">(v, m)</span> </span>{
        <span class="hljs-keyword">var</span> t0 = v[<span class="hljs-number">0</span>] - (v[<span class="hljs-number">0</span>] * m[<span class="hljs-number">0</span>] + v[<span class="hljs-number">1</span>] * m[<span class="hljs-number">4</span>] + v[<span class="hljs-number">2</span>] * m[<span class="hljs-number">8</span>]);
        <span class="hljs-keyword">var</span> t1 = v[<span class="hljs-number">1</span>] - (v[<span class="hljs-number">0</span>] * m[<span class="hljs-number">1</span>] + v[<span class="hljs-number">1</span>] * m[<span class="hljs-number">5</span>] + v[<span class="hljs-number">2</span>] * m[<span class="hljs-number">9</span>]);
        <span class="hljs-keyword">var</span> t2 = v[<span class="hljs-number">2</span>] - (v[<span class="hljs-number">0</span>] * m[<span class="hljs-number">2</span>] + v[<span class="hljs-number">1</span>] * m[<span class="hljs-number">6</span>] + v[<span class="hljs-number">2</span>] * m[<span class="hljs-number">10</span>]);
        <span class="hljs-keyword">return</span> Transform.thenMove(m, [t0, t1, t2]);
    };

    <span class="hljs-comment">/**
     * Return a Transform representation of a skew transformation
     *
     * @method skew
     * @static
     * @param {Number} phi scale factor skew in the x axis
     * @param {Number} theta scale factor skew in the y axis
     * @param {Number} psi scale factor skew in the z axis
     * @return {Transform}
     */</span>
    Transform.skew = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skew</span><span class="hljs-params">(phi, theta, psi)</span> </span>{
        <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-built_in">Math</span>.tan(theta), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.tan(psi), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.tan(phi), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];
    };

    <span class="hljs-comment">/**
     * Return a Transform representation of a skew in the x-direction
     *
     * @method skewX
     * @static
     * @param {Number} angle the angle between the top and left sides
     * @return {Transform}
     */</span>
    Transform.skewX = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skewX</span><span class="hljs-params">(angle)</span> </span>{
        <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.tan(angle), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];
    };

    <span class="hljs-comment">/**
     * Return a Transform representation of a skew in the y-direction
     *
     * @method skewY
     * @static
     * @param {Number} angle the angle between the top and right sides
     * @return {Transform}
     */</span>
    Transform.skewY = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skewY</span><span class="hljs-params">(angle)</span> </span>{
        <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-built_in">Math</span>.tan(angle), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];
    };

    <span class="hljs-comment">/**
     * Returns a perspective Transform matrix
     *
     * @method perspective
     * @static
     * @param {Number} focusZ z position of focal point
     * @return {Transform}
     */</span>
    Transform.perspective = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">perspective</span><span class="hljs-params">(focusZ)</span> </span>{
        <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span> / focusZ, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];
    };

    <span class="hljs-comment">/**
     * Return translation vector component of given Transform
     *
     * @method getTranslate
     * @static
     * @param {Transform} m Transform
     * @return {Array.Number} the translation vector [t_x, t_y, t_z]
     */</span>
    Transform.getTranslate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTranslate</span><span class="hljs-params">(m)</span> </span>{
        <span class="hljs-keyword">return</span> [m[<span class="hljs-number">12</span>], m[<span class="hljs-number">13</span>], m[<span class="hljs-number">14</span>]];
    };

    <span class="hljs-comment">/**
     * Return inverse affine transform for given Transform.
     *   Note: This assumes m[3] = m[7] = m[11] = 0, and m[15] = 1.
     *   Will provide incorrect results if not invertible or preconditions not met.
     *
     * @method inverse
     * @static
     * @param {Transform} m Transform
     * @return {Transform}
     */</span>
    Transform.inverse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inverse</span><span class="hljs-params">(m)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>only need to consider 3x3 section for affine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> c0 = m[<span class="hljs-number">5</span>] * m[<span class="hljs-number">10</span>] - m[<span class="hljs-number">6</span>] * m[<span class="hljs-number">9</span>];
        <span class="hljs-keyword">var</span> c1 = m[<span class="hljs-number">4</span>] * m[<span class="hljs-number">10</span>] - m[<span class="hljs-number">6</span>] * m[<span class="hljs-number">8</span>];
        <span class="hljs-keyword">var</span> c2 = m[<span class="hljs-number">4</span>] * m[<span class="hljs-number">9</span>] - m[<span class="hljs-number">5</span>] * m[<span class="hljs-number">8</span>];
        <span class="hljs-keyword">var</span> c4 = m[<span class="hljs-number">1</span>] * m[<span class="hljs-number">10</span>] - m[<span class="hljs-number">2</span>] * m[<span class="hljs-number">9</span>];
        <span class="hljs-keyword">var</span> c5 = m[<span class="hljs-number">0</span>] * m[<span class="hljs-number">10</span>] - m[<span class="hljs-number">2</span>] * m[<span class="hljs-number">8</span>];
        <span class="hljs-keyword">var</span> c6 = m[<span class="hljs-number">0</span>] * m[<span class="hljs-number">9</span>] - m[<span class="hljs-number">1</span>] * m[<span class="hljs-number">8</span>];
        <span class="hljs-keyword">var</span> c8 = m[<span class="hljs-number">1</span>] * m[<span class="hljs-number">6</span>] - m[<span class="hljs-number">2</span>] * m[<span class="hljs-number">5</span>];
        <span class="hljs-keyword">var</span> c9 = m[<span class="hljs-number">0</span>] * m[<span class="hljs-number">6</span>] - m[<span class="hljs-number">2</span>] * m[<span class="hljs-number">4</span>];
        <span class="hljs-keyword">var</span> c10 = m[<span class="hljs-number">0</span>] * m[<span class="hljs-number">5</span>] - m[<span class="hljs-number">1</span>] * m[<span class="hljs-number">4</span>];
        <span class="hljs-keyword">var</span> detM = m[<span class="hljs-number">0</span>] * c0 - m[<span class="hljs-number">1</span>] * c1 + m[<span class="hljs-number">2</span>] * c2;
        <span class="hljs-keyword">var</span> invD = <span class="hljs-number">1</span> / detM;
        <span class="hljs-keyword">var</span> result = [
            invD * c0, -invD * c4, invD * c8, <span class="hljs-number">0</span>,
            -invD * c1, invD * c5, -invD * c9, <span class="hljs-number">0</span>,
            invD * c2, -invD * c6, invD * c10, <span class="hljs-number">0</span>,
            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
        ];
        result[<span class="hljs-number">12</span>] = -m[<span class="hljs-number">12</span>] * result[<span class="hljs-number">0</span>] - m[<span class="hljs-number">13</span>] * result[<span class="hljs-number">4</span>] - m[<span class="hljs-number">14</span>] * result[<span class="hljs-number">8</span>];
        result[<span class="hljs-number">13</span>] = -m[<span class="hljs-number">12</span>] * result[<span class="hljs-number">1</span>] - m[<span class="hljs-number">13</span>] * result[<span class="hljs-number">5</span>] - m[<span class="hljs-number">14</span>] * result[<span class="hljs-number">9</span>];
        result[<span class="hljs-number">14</span>] = -m[<span class="hljs-number">12</span>] * result[<span class="hljs-number">2</span>] - m[<span class="hljs-number">13</span>] * result[<span class="hljs-number">6</span>] - m[<span class="hljs-number">14</span>] * result[<span class="hljs-number">10</span>];
        <span class="hljs-keyword">return</span> result;
    };

    <span class="hljs-comment">/**
     * Returns the transpose of a 4x4 matrix
     *
     * @method transpose
     * @static
     * @param {Transform} m matrix
     * @return {Transform} the resulting transposed matrix
     */</span>
    Transform.transpose = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transpose</span><span class="hljs-params">(m)</span> </span>{
        <span class="hljs-keyword">return</span> [m[<span class="hljs-number">0</span>], m[<span class="hljs-number">4</span>], m[<span class="hljs-number">8</span>], m[<span class="hljs-number">12</span>], m[<span class="hljs-number">1</span>], m[<span class="hljs-number">5</span>], m[<span class="hljs-number">9</span>], m[<span class="hljs-number">13</span>], m[<span class="hljs-number">2</span>], m[<span class="hljs-number">6</span>], m[<span class="hljs-number">10</span>], m[<span class="hljs-number">14</span>], m[<span class="hljs-number">3</span>], m[<span class="hljs-number">7</span>], m[<span class="hljs-number">11</span>], m[<span class="hljs-number">15</span>]];
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_normSquared</span><span class="hljs-params">(v)</span> </span>{
        <span class="hljs-keyword">return</span> (v.length === <span class="hljs-number">2</span>) ? v[<span class="hljs-number">0</span>] * v[<span class="hljs-number">0</span>] + v[<span class="hljs-number">1</span>] * v[<span class="hljs-number">1</span>] : v[<span class="hljs-number">0</span>] * v[<span class="hljs-number">0</span>] + v[<span class="hljs-number">1</span>] * v[<span class="hljs-number">1</span>] + v[<span class="hljs-number">2</span>] * v[<span class="hljs-number">2</span>];
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_norm</span><span class="hljs-params">(v)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(_normSquared(v));
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_sign</span><span class="hljs-params">(n)</span> </span>{
        <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">/**
     * Decompose Transform into separate .translate, .rotate, .scale,
     *    and .skew components.
     *
     * @method interpret
     * @static
     * @param {Transform} M transform matrix
     * @return {Object} matrix spec object with component matrices .translate,
     *    .rotate, .scale, .skew
     */</span>
    Transform.interpret = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">interpret</span><span class="hljs-params">(M)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>QR decomposition via Householder reflections
FIRST ITERATION</p>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>default Q1 to the identity matrix;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> x = [M[<span class="hljs-number">0</span>], M[<span class="hljs-number">1</span>], M[<span class="hljs-number">2</span>]];                <span class="hljs-comment">// first column vector</span>
        <span class="hljs-keyword">var</span> sgn = _sign(x[<span class="hljs-number">0</span>]);                     <span class="hljs-comment">// sign of first component of x (for stability)</span>
        <span class="hljs-keyword">var</span> xNorm = _norm(x);                      <span class="hljs-comment">// norm of first column vector</span>
        <span class="hljs-keyword">var</span> v = [x[<span class="hljs-number">0</span>] + sgn * xNorm, x[<span class="hljs-number">1</span>], x[<span class="hljs-number">2</span>]];  <span class="hljs-comment">// v = x + sign(x[0])|x|e1</span>
        <span class="hljs-keyword">var</span> mult = <span class="hljs-number">2</span> / _normSquared(v);            <span class="hljs-comment">// mult = 2/v'v</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>bail out if our Matrix is singular</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (mult &gt;= <span class="hljs-literal">Infinity</span>) {
            <span class="hljs-keyword">return</span> {translate: Transform.getTranslate(M), rotate: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], scale: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], skew: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]};
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>evaluate Q1 = I - 2vv’/v’v</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> Q1 = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>diagonals</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        Q1[<span class="hljs-number">0</span>]  = <span class="hljs-number">1</span> - mult * v[<span class="hljs-number">0</span>] * v[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 0,0 entry</span>
        Q1[<span class="hljs-number">5</span>]  = <span class="hljs-number">1</span> - mult * v[<span class="hljs-number">1</span>] * v[<span class="hljs-number">1</span>];    <span class="hljs-comment">// 1,1 entry</span>
        Q1[<span class="hljs-number">10</span>] = <span class="hljs-number">1</span> - mult * v[<span class="hljs-number">2</span>] * v[<span class="hljs-number">2</span>];    <span class="hljs-comment">// 2,2 entry</span></pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>upper diagonal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        Q1[<span class="hljs-number">1</span>] = -mult * v[<span class="hljs-number">0</span>] * v[<span class="hljs-number">1</span>];        <span class="hljs-comment">// 0,1 entry</span>
        Q1[<span class="hljs-number">2</span>] = -mult * v[<span class="hljs-number">0</span>] * v[<span class="hljs-number">2</span>];        <span class="hljs-comment">// 0,2 entry</span>
        Q1[<span class="hljs-number">6</span>] = -mult * v[<span class="hljs-number">1</span>] * v[<span class="hljs-number">2</span>];        <span class="hljs-comment">// 1,2 entry</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>lower diagonal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        Q1[<span class="hljs-number">4</span>] = Q1[<span class="hljs-number">1</span>];                      <span class="hljs-comment">// 1,0 entry</span>
        Q1[<span class="hljs-number">8</span>] = Q1[<span class="hljs-number">2</span>];                      <span class="hljs-comment">// 2,0 entry</span>
        Q1[<span class="hljs-number">9</span>] = Q1[<span class="hljs-number">6</span>];                      <span class="hljs-comment">// 2,1 entry</span></pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>reduce first column of M</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> MQ1 = Transform.multiply(Q1, M);</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>SECOND ITERATION on (1,1) minor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> x2 = [MQ1[<span class="hljs-number">5</span>], MQ1[<span class="hljs-number">6</span>]];
        <span class="hljs-keyword">var</span> sgn2 = _sign(x2[<span class="hljs-number">0</span>]);                    <span class="hljs-comment">// sign of first component of x (for stability)</span>
        <span class="hljs-keyword">var</span> x2Norm = _norm(x2);                     <span class="hljs-comment">// norm of first column vector</span>
        <span class="hljs-keyword">var</span> v2 = [x2[<span class="hljs-number">0</span>] + sgn2 * x2Norm, x2[<span class="hljs-number">1</span>]];    <span class="hljs-comment">// v = x + sign(x[0])|x|e1</span>
        <span class="hljs-keyword">var</span> mult2 = <span class="hljs-number">2</span> / _normSquared(v2);           <span class="hljs-comment">// mult = 2/v'v</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>evaluate Q2 = I - 2vv’/v’v</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> Q2 = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>diagonal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        Q2[<span class="hljs-number">5</span>]  = <span class="hljs-number">1</span> - mult2 * v2[<span class="hljs-number">0</span>] * v2[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 1,1 entry</span>
        Q2[<span class="hljs-number">10</span>] = <span class="hljs-number">1</span> - mult2 * v2[<span class="hljs-number">1</span>] * v2[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 2,2 entry</span></pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>off diagonals</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        Q2[<span class="hljs-number">6</span>] = -mult2 * v2[<span class="hljs-number">0</span>] * v2[<span class="hljs-number">1</span>];     <span class="hljs-comment">// 2,1 entry</span>
        Q2[<span class="hljs-number">9</span>] = Q2[<span class="hljs-number">6</span>];                      <span class="hljs-comment">// 1,2 entry</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>calc QR decomposition. Q = Q1<em>Q2, R = Q’</em>M</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> Q = Transform.multiply(Q2, Q1);      <span class="hljs-comment">//note: really Q transpose</span>
        <span class="hljs-keyword">var</span> R = Transform.multiply(Q, M);</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>remove negative scaling</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> remover = Transform.scale(R[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>, R[<span class="hljs-number">5</span>] &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>, R[<span class="hljs-number">10</span>] &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
        R = Transform.multiply(R, remover);
        Q = Transform.multiply(remover, Q);</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>decompose into rotate/scale/skew matrices</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> result = {};
        result.translate = Transform.getTranslate(M);
        result.rotate = [<span class="hljs-built_in">Math</span>.atan2(-Q[<span class="hljs-number">6</span>], Q[<span class="hljs-number">10</span>]), <span class="hljs-built_in">Math</span>.asin(Q[<span class="hljs-number">2</span>]), <span class="hljs-built_in">Math</span>.atan2(-Q[<span class="hljs-number">1</span>], Q[<span class="hljs-number">0</span>])];
        <span class="hljs-keyword">if</span> (!result.rotate[<span class="hljs-number">0</span>]) {
            result.rotate[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
            result.rotate[<span class="hljs-number">2</span>] = <span class="hljs-built_in">Math</span>.atan2(Q[<span class="hljs-number">4</span>], Q[<span class="hljs-number">5</span>]);
        }
        result.scale = [R[<span class="hljs-number">0</span>], R[<span class="hljs-number">5</span>], R[<span class="hljs-number">10</span>]];
        result.skew = [<span class="hljs-built_in">Math</span>.atan2(R[<span class="hljs-number">9</span>], result.scale[<span class="hljs-number">2</span>]), <span class="hljs-built_in">Math</span>.atan2(R[<span class="hljs-number">8</span>], result.scale[<span class="hljs-number">2</span>]), <span class="hljs-built_in">Math</span>.atan2(R[<span class="hljs-number">4</span>], result.scale[<span class="hljs-number">0</span>])];</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>double rotation workaround</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(result.rotate[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">Math</span>.abs(result.rotate[<span class="hljs-number">2</span>]) &gt; <span class="hljs-number">1.5</span> * <span class="hljs-built_in">Math</span>.PI) {
            result.rotate[<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.PI - result.rotate[<span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (result.rotate[<span class="hljs-number">1</span>] &gt; <span class="hljs-built_in">Math</span>.PI) result.rotate[<span class="hljs-number">1</span>] -= <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI;
            <span class="hljs-keyword">if</span> (result.rotate[<span class="hljs-number">1</span>] &lt; -<span class="hljs-built_in">Math</span>.PI) result.rotate[<span class="hljs-number">1</span>] += <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI;
            <span class="hljs-keyword">if</span> (result.rotate[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span>) result.rotate[<span class="hljs-number">0</span>] += <span class="hljs-built_in">Math</span>.PI;
            <span class="hljs-keyword">else</span> result.rotate[<span class="hljs-number">0</span>] -= <span class="hljs-built_in">Math</span>.PI;
            <span class="hljs-keyword">if</span> (result.rotate[<span class="hljs-number">2</span>] &lt; <span class="hljs-number">0</span>) result.rotate[<span class="hljs-number">2</span>] += <span class="hljs-built_in">Math</span>.PI;
            <span class="hljs-keyword">else</span> result.rotate[<span class="hljs-number">2</span>] -= <span class="hljs-built_in">Math</span>.PI;
        }

        <span class="hljs-keyword">return</span> result;
    };

    <span class="hljs-comment">/**
     * Weighted average between two matrices by averaging their
     *     translation, rotation, scale, skew components.
     *     f(M1,M2,t) = (1 - t) * M1 + t * M2
     *
     * @method average
     * @static
     * @param {Transform} M1 f(M1,M2,0) = M1
     * @param {Transform} M2 f(M1,M2,1) = M2
     * @param {Number} t
     * @return {Transform}
     */</span>
    Transform.average = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">average</span><span class="hljs-params">(M1, M2, t)</span> </span>{
        t = (t === <span class="hljs-literal">undefined</span>) ? <span class="hljs-number">0.5</span> : t;
        <span class="hljs-keyword">var</span> specM1 = Transform.interpret(M1);
        <span class="hljs-keyword">var</span> specM2 = Transform.interpret(M2);

        <span class="hljs-keyword">var</span> specAvg = {
            translate: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
            rotate: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
            scale: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
            skew: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
        };

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
            specAvg.translate[i] = (<span class="hljs-number">1</span> - t) * specM1.translate[i] + t * specM2.translate[i];
            specAvg.rotate[i] = (<span class="hljs-number">1</span> - t) * specM1.rotate[i] + t * specM2.rotate[i];
            specAvg.scale[i] = (<span class="hljs-number">1</span> - t) * specM1.scale[i] + t * specM2.scale[i];
            specAvg.skew[i] = (<span class="hljs-number">1</span> - t) * specM1.skew[i] + t * specM2.skew[i];
        }
        <span class="hljs-keyword">return</span> Transform.build(specAvg);
    };

    <span class="hljs-comment">/**
     * Compose .translate, .rotate, .scale, .skew components into
     * Transform matrix
     *
     * @method build
     * @static
     * @param {matrixSpec} spec object with component matrices .translate,
     *    .rotate, .scale, .skew
     * @return {Transform} composed transform
     */</span>
    Transform.build = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">build</span><span class="hljs-params">(spec)</span> </span>{
        <span class="hljs-keyword">var</span> scaleMatrix = Transform.scale(spec.scale[<span class="hljs-number">0</span>], spec.scale[<span class="hljs-number">1</span>], spec.scale[<span class="hljs-number">2</span>]);
        <span class="hljs-keyword">var</span> skewMatrix = Transform.skew(spec.skew[<span class="hljs-number">0</span>], spec.skew[<span class="hljs-number">1</span>], spec.skew[<span class="hljs-number">2</span>]);
        <span class="hljs-keyword">var</span> rotateMatrix = Transform.rotate(spec.rotate[<span class="hljs-number">0</span>], spec.rotate[<span class="hljs-number">1</span>], spec.rotate[<span class="hljs-number">2</span>]);
        <span class="hljs-keyword">return</span> Transform.thenMove(Transform.multiply(Transform.multiply(rotateMatrix, skewMatrix), scaleMatrix), spec.translate);
    };

    <span class="hljs-comment">/**
     * Determine if two Transforms are component-wise equal
     *   Warning: breaks on perspective Transforms
     *
     * @method equals
     * @static
     * @param {Transform} a matrix
     * @param {Transform} b matrix
     * @return {boolean}
     */</span>
    Transform.equals = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">equals</span><span class="hljs-params">(a, b)</span> </span>{
        <span class="hljs-keyword">return</span> !Transform.notEquals(a, b);
    };

    <span class="hljs-comment">/**
     * Determine if two Transforms are component-wise unequal
     *   Warning: breaks on perspective Transforms
     *
     * @method notEquals
     * @static
     * @param {Transform} a matrix
     * @param {Transform} b matrix
     * @return {boolean}
     */</span>
    Transform.notEquals = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notEquals</span><span class="hljs-params">(a, b)</span> </span>{
        <span class="hljs-keyword">if</span> (a === b) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>shortci</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> !(a &amp;&amp; b) ||
            a[<span class="hljs-number">12</span>] !== b[<span class="hljs-number">12</span>] || a[<span class="hljs-number">13</span>] !== b[<span class="hljs-number">13</span>] || a[<span class="hljs-number">14</span>] !== b[<span class="hljs-number">14</span>] ||
            a[<span class="hljs-number">0</span>] !== b[<span class="hljs-number">0</span>] || a[<span class="hljs-number">1</span>] !== b[<span class="hljs-number">1</span>] || a[<span class="hljs-number">2</span>] !== b[<span class="hljs-number">2</span>] ||
            a[<span class="hljs-number">4</span>] !== b[<span class="hljs-number">4</span>] || a[<span class="hljs-number">5</span>] !== b[<span class="hljs-number">5</span>] || a[<span class="hljs-number">6</span>] !== b[<span class="hljs-number">6</span>] ||
            a[<span class="hljs-number">8</span>] !== b[<span class="hljs-number">8</span>] || a[<span class="hljs-number">9</span>] !== b[<span class="hljs-number">9</span>] || a[<span class="hljs-number">10</span>] !== b[<span class="hljs-number">10</span>];
    };

    <span class="hljs-comment">/**
     * Constrain angle-trio components to range of [-pi, pi).
     *
     * @method normalizeRotation
     * @static
     * @param {Array.Number} rotation phi, theta, psi (array of floats
     *    &amp;&amp; array.length == 3)
     * @return {Array.Number} new phi, theta, psi triplet
     *    (array of floats &amp;&amp; array.length == 3)
     */</span>
    Transform.normalizeRotation = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeRotation</span><span class="hljs-params">(rotation)</span> </span>{
        <span class="hljs-keyword">var</span> result = rotation.slice(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (result[<span class="hljs-number">0</span>] === <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">0.5</span> || result[<span class="hljs-number">0</span>] === -<span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">0.5</span>) {
            result[<span class="hljs-number">0</span>] = -result[<span class="hljs-number">0</span>];
            result[<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.PI - result[<span class="hljs-number">1</span>];
            result[<span class="hljs-number">2</span>] -= <span class="hljs-built_in">Math</span>.PI;
        }
        <span class="hljs-keyword">if</span> (result[<span class="hljs-number">0</span>] &gt; <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">0.5</span>) {
            result[<span class="hljs-number">0</span>] = result[<span class="hljs-number">0</span>] - <span class="hljs-built_in">Math</span>.PI;
            result[<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.PI - result[<span class="hljs-number">1</span>];
            result[<span class="hljs-number">2</span>] -= <span class="hljs-built_in">Math</span>.PI;
        }
        <span class="hljs-keyword">if</span> (result[<span class="hljs-number">0</span>] &lt; -<span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">0.5</span>) {
            result[<span class="hljs-number">0</span>] = result[<span class="hljs-number">0</span>] + <span class="hljs-built_in">Math</span>.PI;
            result[<span class="hljs-number">1</span>] = -<span class="hljs-built_in">Math</span>.PI - result[<span class="hljs-number">1</span>];
            result[<span class="hljs-number">2</span>] -= <span class="hljs-built_in">Math</span>.PI;
        }
        <span class="hljs-keyword">while</span> (result[<span class="hljs-number">1</span>] &lt; -<span class="hljs-built_in">Math</span>.PI) result[<span class="hljs-number">1</span>] += <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI;
        <span class="hljs-keyword">while</span> (result[<span class="hljs-number">1</span>] &gt;= <span class="hljs-built_in">Math</span>.PI) result[<span class="hljs-number">1</span>] -= <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI;
        <span class="hljs-keyword">while</span> (result[<span class="hljs-number">2</span>] &lt; -<span class="hljs-built_in">Math</span>.PI) result[<span class="hljs-number">2</span>] += <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI;
        <span class="hljs-keyword">while</span> (result[<span class="hljs-number">2</span>] &gt;= <span class="hljs-built_in">Math</span>.PI) result[<span class="hljs-number">2</span>] -= <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI;
        <span class="hljs-keyword">return</span> result;
    };

    <span class="hljs-comment">/**
     * (Property) Array defining a translation forward in z by 1
     *
     * @property {array} inFront
     * @static
     * @final
     */</span>
    Transform.inFront = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1e-3</span>, <span class="hljs-number">1</span>];

    <span class="hljs-comment">/**
     * (Property) Array defining a translation backwards in z by 1
     *
     * @property {array} behind
     * @static
     * @final
     */</span>
    Transform.behind = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1e-3</span>, <span class="hljs-number">1</span>];

    <span class="hljs-built_in">module</span>.exports = Transform;
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
